```@meta
DocTestSetup = quote
   using QuantumWalk, LightGraphs
end
```

## Quantum Search

Quantum spatial search is an algorithm, which starts at some initial state (which
 depends on the graph structure), and runs for some time in order to cumulate
 amplitude at marked vertex. The algorithm is known to outperform classical search.

 The dynamics requires `evolve`, `measure`, `initial_state` and `check_qwdynamics` functions. It provides `execute`, `execute_single`, `execute_single_measured`, `execute_all` and `execute_all_measured` functions - the description can be found in [Quantum walk evolution](quantum_walk.md) section. The only difference is that `QWSearch` uses the state generated by `initial_state` function if not provided. Furthermore the function provides `marked`, `penalty` and `maximize_quantum_search`. The first two returns the parameters from `QWSearch`. The last one searches for optimal measure time. The maximization methods depends on the model (if it is continuous or discrete).

 The `penalty` is an additional time added in optimization. Note, that if we optimize
 time/success\_probability(time) function, the optimum is always at time 0. This would imply that algorithm achieves full efficiency if it is instantly measured. This is misleading, as the time for constructing initial state and for measurement is ignored.
 Hence we need to include (usually small) additional time in `penalty` in order to
 get useful result. Note the time/success\_probability(time) is at called
 *expected runtime* and can be obtained by `expected_runtime` function.

 Some function as a result outputs `QSearchState` instead of the original state.
 It consists of the original state, the runtime, the probability of measuring
 each marked vertex, and penalty used for computing `QSearchState`. Those elements can be extracted by `state`, `runtime`, `probability` and `penalty` functions.

## Example

```julia
julia> n = 100;

julia> penalty_szegedy = log(n);

julia> qsearch = QWSearch(Szegedy(CompleteGraph(n)), [1], penalty_szegedy);

julia> runtime(maximize_quantum_search(qsearch))-penalty_szegedy
5.0

julia> probability(maximize_quantum_search(qsearch))
1-element Array{Float64,1}:
 0.569689

julia> execute_single_measured(qsearch, ceil(Int, pi*sqrt(100)/2))
100-element Array{Float64,1}:
 0.428475  
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 ⋮         
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
```

## Adjusting model to `QWSearch`

Here we consider the example from the [Quantum walk evolution](quantum_walk.md) section. We consider
random walk search as follows: at given step we check if we are at the marked vertex.
If not, we continue evolution. Hence we need to cumulate the success probability
at marked vertices. We propose following implementation (including the functions
from mentioned section). Again some additional assertion could be included for
full functionality.

```julia
function check_qwdynamics(::Type{QWSearch},
                          abs_stoch::UniformStochastic,
                          ::Vector{Int},
                          parameters::Dict{Symbol,Any})
  @assert :stochastic ∈ keys(parameters) "parameters needs to have key stochastic"
  n = nv(graph(abs_stoch))
  @assert isa(parameters[:stochastic], SparseMatrixCSC{<:Real}) "value for :stochastic needs to be sparse matrix with real numbers"
  @assert size(parameters[:stochastic], 1) == size(parameters[:stochastic], 2) "Stochastic matrix needs to be square stochastic matrix"
  @assert mapslices(sum, parameters[:stochastic], 1)[1,:] ≈ ones(n) "Stochastic matrix needs to be square stochastic matrix of order graph"
end

function QWSearch(stoch::AbstractStochastic,
                  marked::Vector{Int},
                  penalty::Real = 0.)
   parameters = Dict{Symbol,Any}(:stochastic => stochastic_matrix(graph(stoch)))

   QWSearch(stoch, marked, parameters, penalty)
end

function initial_state(qws::QWSearch{<:AbstractStochastic})
  n = nv(graph(qws))
  fill(1./n, n)
end

function evolve(qws::QWSearch{<:AbstractStochastic}, state::Vector{<:Real})
  old_probability = measure(qws, state, marked(qws))
  state[marked(qws)] = zero(marked(qws))
  state = stochastic_evolution(parameters(qws)[:stochastic], state)
  state[marked(qws)] += old_probability
  state
end
```
Note that for example `measure` function does not change. Below we provide an
evolution simulation example.

```julia
julia> dynamic = QWSearch(UniformStochastic(CompleteGraph(100)), [1])
QuantumWalk.QWSearch{UniformStochastic{LightGraphs.SimpleGraphs.SimpleGraph{Int64}},Float64}(UniformStochastic{LightGraphs.SimpleGraphs.SimpleGraph{Int64}}({100, 4950} undirected simple Int64 graph), [1], Dict{Symbol,Any}(Pair{Symbol,Any}(:stochastic,
  [2  ,   1]  =  0.010101
  [3  ,   1]  =  0.010101
  [4  ,   1]  =  0.010101
  [5  ,   1]  =  0.010101
  [6  ,   1]  =  0.010101
  ⋮
  [94 , 100]  =  0.010101
  [95 , 100]  =  0.010101
  [96 , 100]  =  0.010101
  [97 , 100]  =  0.010101
  [98 , 100]  =  0.010101
  [99 , 100]  =  0.010101)), 0.0)

julia> measure(dynamic, execute_single(dynamic, 0), [1])
1-element Array{Float64,1}:
 0.01

julia> measure(dynamic, execute_single(dynamic, 40), [1])
1-element Array{Float64,1}:
 0.340416

julia> measure(dynamic, execute_single(dynamic, 1000), [1])
1-element Array{Float64,1}:
 0.999961
```

## Documentation

Following functions are connected to the quantum search:
```@index
Order = [:type, :function]
Modules = [QuantumWalk]
Pages   = ["quantum_search.md"]
```


## Full docs

```@docs
QSearchState
QWSearch
execute(::QWSearch, ::Real)
execute_all(::QWSearch{<:QWModelDiscr}, ::S, ::Int) where S
execute_all_measured(::QWSearch{<:QWModelDiscr}, ::Int)
execute_single(::QWSearch{<:QWModelDiscr}, ::Any, ::Int)
execute_single_measured(::QWSearch, ::Int)
expected_runtime(::Real, ::Real)
initial_state
marked(::QWSearch)
maximize_quantum_search(::QWSearch{<:QWModelCont})
maximize_quantum_search(::QWSearch{<:QWModelDiscr})
penalty(::QWSearch)
penalty(::QSearchState)
probability(::QSearchState)
runtime(::QSearchState)
state(::QSearchState)
```
